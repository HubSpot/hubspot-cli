import { ArgumentsCamelCase, Argv } from 'yargs';
import path from 'path';
import fs from 'fs-extra';
import { cloneGithubRepo } from '@hubspot/local-dev-lib/github';
import { getCwd } from '@hubspot/local-dev-lib/path';
import { trackCommandUsage } from '../../lib/usageTracking.js';
import {
  writeProjectConfig,
  getProjectConfig,
} from '../../lib/projects/config.js';
import { EMPTY_PROJECT_TEMPLATE_NAME } from '../../lib/projects/create/legacy.js';
import { generateComponentPaths } from '../../lib/projects/create/v3.js';
import { PROJECT_WITH_APP, EMPTY_PROJECT } from '../../lib/constants.js';
import { uiFeatureHighlight } from '../../lib/ui/index.js';
import { debugError, logError } from '../../lib/errorHandlers/index.js';
import { EXIT_CODES } from '../../lib/enums/exitCodes.js';
import {
  PROJECT_CONFIG_FILE,
  HUBSPOT_PROJECT_COMPONENTS_GITHUB_PATH,
  marketplaceDistribution,
  privateDistribution,
  oAuth,
  staticAuth,
  DEFAULT_PROJECT_TEMPLATE_BRANCH,
} from '../../lib/constants.js';
import { YargsCommandModule } from '../../types/Yargs.js';
import { makeYargsBuilder } from '../../lib/yargsUtils.js';
import { ProjectConfig } from '../../types/Projects.js';

import { PLATFORM_VERSIONS } from '@hubspot/local-dev-lib/constants/projects';
import { commands } from '../../lang/en.js';
import { uiLogger } from '../../lib/ui/logger.js';
import {
  handleProjectCreationFlow,
  ProjectCreateArgs,
} from '../../lib/projects/create/index.js';
import {
  getProjectMetadata,
  ProjectMetadata,
} from '@hubspot/project-parsing-lib/src/lib/project.js';
import { updateHsMetaFilesWithAutoGeneratedFields } from '../../lib/projects/components.js';

const command = ['create', 'init'];
const describe = commands.project.create.describe;

const { v2023_2, v2025_1, v2025_2 } = PLATFORM_VERSIONS;

async function handler(
  args: ArgumentsCamelCase<ProjectCreateArgs>
): Promise<void> {
  const { derivedAccountId, platformVersion, templateSource } = args;

  if (templateSource && !templateSource.includes('/')) {
    uiLogger.error(commands.project.create.errors.invalidTemplateSource);
    process.exit(EXIT_CODES.ERROR);
  }

  const repo = templateSource || HUBSPOT_PROJECT_COMPONENTS_GITHUB_PATH;

  let handleResult;
  try {
    handleResult = await handleProjectCreationFlow(args);
  } catch (error) {
    logError(error);
    process.exit(EXIT_CODES.ERROR);
  }

  const {
    authType,
    distribution,
    repoConfig,
    projectContents,
    selectProjectTemplatePromptResponse,
    projectNameAndDestPromptResponse,
  } = handleResult;

  trackCommandUsage(
    'project-create',
    {
      type:
        selectProjectTemplatePromptResponse.projectTemplate?.name ||
        (selectProjectTemplatePromptResponse.componentTemplates || [])
          // @ts-expect-error
          .map((item: never) => item.type)
          .join(','),
    },
    derivedAccountId
  );

  const projectDest = path.resolve(
    getCwd(),
    projectNameAndDestPromptResponse.dest
  );

  const {
    projectConfig: existingProjectConfig,
    projectDir: existingProjectDir,
  } = await getProjectConfig(projectDest);

  // Exit if the target destination is within an existing project
  if (
    existingProjectConfig &&
    existingProjectDir &&
    projectDest.startsWith(existingProjectDir)
  ) {
    uiLogger.error(
      commands.project.create.errors.cannotNestProjects(existingProjectDir)
    );
    process.exit(EXIT_CODES.ERROR);
  }

  const components: string[] = generateComponentPaths({
    selectProjectTemplatePromptResponse,
    platformVersion,
    repoConfig,
    projectContents,
    authType,
    distribution,
  });

  try {
    await cloneGithubRepo(repo, projectDest, {
      sourceDir:
        selectProjectTemplatePromptResponse.projectTemplate?.path || components,
      hideLogs: true,
      branch: DEFAULT_PROJECT_TEMPLATE_BRANCH,
    });
  } catch (err) {
    debugError(err);
    uiLogger.error(commands.project.create.errors.failedToDownloadProject);
    process.exit(EXIT_CODES.ERROR);
  }

  const projectConfigPath = path.join(projectDest, PROJECT_CONFIG_FILE);

  const parsedConfigFile: ProjectConfig = JSON.parse(
    fs.readFileSync(projectConfigPath).toString()
  );

  const projectName = projectNameAndDestPromptResponse.name;

  writeProjectConfig(projectConfigPath, {
    ...parsedConfigFile,
    name: projectName,
  });

  const projectMetadata: ProjectMetadata = await getProjectMetadata(
    path.join(projectDest, parsedConfigFile.srcDir)
  );

  updateHsMetaFilesWithAutoGeneratedFields(
    projectName,
    projectMetadata.hsMetaFiles
  );

  // If the template is 'no-template', we need to manually create a src directory
  if (
    selectProjectTemplatePromptResponse.projectTemplate?.name ===
      EMPTY_PROJECT_TEMPLATE_NAME ||
    projectContents === EMPTY_PROJECT
  ) {
    fs.ensureDirSync(path.join(projectDest, 'src'));
  }

  uiLogger.success(
    commands.project.create.logs.success(
      projectNameAndDestPromptResponse.name,
      projectDest
    )
  );

  uiLogger.log(commands.project.create.logs.welcomeMessage);
  uiFeatureHighlight([
    'projectCommandTip',
    'projectUploadCommand',
    'projectDevCommand',
    'projectInstallDepsCommand',
    'projectHelpCommand',
    'feedbackCommand',
    'sampleProjects',
  ]);
  process.exit(EXIT_CODES.SUCCESS);
}

function projectCreateBuilder(yargs: Argv): Argv<ProjectCreateArgs> {
  yargs.options({
    name: {
      describe: commands.project.create.options.name.describe,
      type: 'string',
    },
    dest: {
      describe: commands.project.create.options.dest.describe,
      type: 'string',
    },
    template: {
      describe: commands.project.create.options.template.describe,
      type: 'string',
    },
    'template-source': {
      describe: commands.project.create.options.templateSource.describe,
      type: 'string',
    },
    'platform-version': {
      describe: commands.project.create.options.platformVersion.describe,
      type: 'string',
      choices: [v2023_2, v2025_1, v2025_2],
      default: v2025_2,
    },
    'project-base': {
      describe: commands.project.create.options.projectBase.describe,
      type: 'string',
      choices: [EMPTY_PROJECT, PROJECT_WITH_APP],
    },
    distribution: {
      describe: commands.project.create.options.distribution.describe,
      type: 'string',
      choices: [privateDistribution, marketplaceDistribution],
    },
    auth: {
      describe: commands.project.create.options.auth.describe,
      type: 'string',
      choices: [oAuth, staticAuth],
    },
    features: {
      describe: commands.project.create.options.features.describe,
      type: 'array',
    },
  });

  yargs.conflicts('template', 'features');

  yargs.example([
    ['$0 project create', commands.project.create.examples.default],
  ]);
  yargs.example([
    [
      '$0 project create --template-source HubSpot/ui-extensions-examples',
      commands.project.create.examples.templateSource,
    ],
  ]);

  return yargs as Argv<ProjectCreateArgs>;
}

const builder = makeYargsBuilder<ProjectCreateArgs>(
  projectCreateBuilder,
  command,
  describe,
  {
    useGlobalOptions: true,
    useAccountOptions: true,
    useConfigOptions: true,
    useEnvironmentOptions: true,
  }
);

const projectCreateCommand: YargsCommandModule<unknown, ProjectCreateArgs> = {
  command,
  describe,
  handler,
  builder,
};

export default projectCreateCommand;
