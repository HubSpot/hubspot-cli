import fs from 'fs';
import { Collision } from '@hubspot/local-dev-lib/types/Archive';
import {
  handleComponentCollision,
  updateHsMetaFilesWithAutoGeneratedFields,
} from '../components.js';
import { uiLogger } from '../../ui/logger.js';
import { coerceToValidUid } from '@hubspot/project-parsing-lib';

vi.mock('fs');
vi.mock('../../ui/logger.js');
vi.mock('@hubspot/project-parsing-lib', () => ({
  coerceToValidUid: vi.fn(),
  metafileExtension: '.module.meta.json',
}));
vi.mock('@hubspot/project-parsing-lib/src/lib/constants.js', () => ({
  AppKey: 'app',
}));
vi.mock('../../../lang/en.js', () => ({
  lib: {
    projects: {
      updateHsMetaFilesWithAutoGeneratedFields: {
        header: 'Updating component metadata files...',
        applicationLog: (type: string, uid: string, name: string) =>
          `Updated ${type} component with uid: ${uid} and name: ${name}`,
        componentLog: (type: string, uid: string) =>
          `Updated ${type} component with uid: ${uid}`,
      },
    },
  },
}));

const mockedFs = vi.mocked(fs);
const mockCoerceToValidUid = vi.mocked(coerceToValidUid);

describe('lib/projects/components', () => {
  describe('handleComponentCollision()', () => {
    const mockCollision: Collision = {
      dest: '/dest/path',
      src: '/src/path',
      collisions: [],
    };

    beforeEach(() => {
      vi.resetAllMocks();

      // Mock Date.now to return consistent values for testing
      vi.spyOn(Date, 'now').mockReturnValue(1234567890);
    });

    afterEach(() => {
      vi.restoreAllMocks();
    });

    it('handles source file collisions by renaming them with timestamps', () => {
      const collision: Collision = {
        ...mockCollision,
        collisions: ['component.js', 'utils.ts'],
      };

      mockedFs.copyFileSync.mockImplementation(() => {});

      handleComponentCollision(collision);

      expect(mockedFs.copyFileSync).toHaveBeenCalledTimes(2);
      expect(mockedFs.copyFileSync).toHaveBeenCalledWith(
        '/src/path/component.js',
        '/dest/path/component-1234567890.js'
      );
      expect(mockedFs.copyFileSync).toHaveBeenCalledWith(
        '/src/path/utils.ts',
        '/dest/path/utils-1234567890.ts'
      );
    });

    it('handles metafile collisions by renaming and updating references', () => {
      const collision: Collision = {
        ...mockCollision,
        collisions: ['component.module.meta.json', 'source.js'],
      };

      const mockMetaContent = JSON.stringify({
        file: 'source.js',
        label: 'Test Component',
      });

      mockedFs.readFileSync.mockReturnValue(mockMetaContent);
      mockedFs.writeFileSync.mockImplementation(() => {});
      mockedFs.copyFileSync.mockImplementation(() => {});

      // Mock metafileExtension
      Object.defineProperty(
        require('@hubspot/project-parsing-lib'),
        'metafileExtension',
        {
          value: '.module.meta.json',
          writable: false,
        }
      );

      handleComponentCollision(collision);

      expect(mockedFs.readFileSync).toHaveBeenCalledWith(
        '/src/path/component.module.meta.json',
        'utf-8'
      );
      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        '/dest/path/component-1234567890.module.meta.json',
        expect.stringContaining('source-1234567890.js')
      );
      expect(mockedFs.copyFileSync).toHaveBeenCalledWith(
        '/src/path/source.js',
        '/dest/path/source-1234567890.js'
      );
    });

    it('handles package.json collisions by merging dependencies', () => {
      const collision: Collision = {
        ...mockCollision,
        collisions: ['package.json'],
      };

      const existingPackageJson = {
        name: 'existing-package',
        dependencies: {
          existing: '1.0.0',
          shared: '1.0.0',
        },
        devDependencies: {
          'existing-dev': '1.0.0',
        },
      };

      const newPackageJson = {
        name: 'new-package',
        dependencies: {
          new: '2.0.0',
          shared: '2.0.0',
        },
        devDependencies: {
          'new-dev': '2.0.0',
          'existing-dev': '2.0.0',
        },
      };

      mockedFs.readFileSync
        .mockReturnValueOnce(JSON.stringify(existingPackageJson))
        .mockReturnValueOnce(JSON.stringify(newPackageJson));

      mockedFs.writeFileSync.mockImplementation(() => {});

      // Mock console.log to avoid output during tests
      const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});

      handleComponentCollision(collision);

      const expectedMergedPackageJson = {
        name: 'existing-package',
        dependencies: {
          new: '2.0.0',
          shared: '1.0.0',
          existing: '1.0.0',
        },
        devDependencies: {
          'new-dev': '2.0.0',
          'existing-dev': '1.0.0',
        },
      };

      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        '/dest/path/package.json',
        JSON.stringify(expectedMergedPackageJson, null, 2)
      );

      consoleSpy.mockRestore();
    });

    it('handles mixed collision types (source files, metafiles, and package.json)', () => {
      const collision: Collision = {
        ...mockCollision,
        collisions: [
          'component.js',
          'component.module.meta.json',
          'package.json',
          'utils.ts',
        ],
      };

      const mockMetaContent = JSON.stringify({
        file: 'component.js',
        label: 'Test Component',
      });

      const existingPackageJson = { name: 'existing' };
      const newPackageJson = { name: 'new', dependencies: { test: '1.0.0' } };

      mockedFs.readFileSync
        .mockReturnValueOnce(mockMetaContent)
        .mockReturnValueOnce(JSON.stringify(existingPackageJson))
        .mockReturnValueOnce(JSON.stringify(newPackageJson));

      mockedFs.writeFileSync.mockImplementation(() => {});
      mockedFs.copyFileSync.mockImplementation(() => {});

      // Mock metafileExtension
      Object.defineProperty(
        require('@hubspot/project-parsing-lib'),
        'metafileExtension',
        {
          value: '.module.meta.json',
          writable: false,
        }
      );

      const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});

      handleComponentCollision(collision);

      // Verify source files are copied with new names
      expect(mockedFs.copyFileSync).toHaveBeenCalledWith(
        '/src/path/component.js',
        '/dest/path/component-1234567890.js'
      );
      expect(mockedFs.copyFileSync).toHaveBeenCalledWith(
        '/src/path/utils.ts',
        '/dest/path/utils-1234567890.ts'
      );

      // Verify metafile is updated and written with new name
      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        '/dest/path/component-1234567890.module.meta.json',
        expect.stringContaining('component-1234567890.js')
      );

      // Verify package.json is merged
      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        '/dest/path/package.json',
        expect.stringContaining('"dependencies"')
      );

      consoleSpy.mockRestore();
    });

    it('handles empty collisions array gracefully', () => {
      const collision: Collision = {
        ...mockCollision,
        collisions: [],
      };

      handleComponentCollision(collision);

      expect(mockedFs.copyFileSync).not.toHaveBeenCalled();
      expect(mockedFs.readFileSync).not.toHaveBeenCalled();
      expect(mockedFs.writeFileSync).not.toHaveBeenCalled();
    });

    it('correctly categorizes different file types', () => {
      const collision: Collision = {
        ...mockCollision,
        collisions: [
          'regular.js',
          'nested/path/file.ts',
          'component.meta.json',
          'another.meta.json',
          'package.json',
        ],
      };

      // Mock metafileExtension
      Object.defineProperty(
        require('@hubspot/project-parsing-lib'),
        'metafileExtension',
        {
          value: '.meta.json',
          writable: false,
        }
      );

      const mockMetaContent = '{}';

      mockedFs.readFileSync.mockReturnValue(mockMetaContent);
      mockedFs.writeFileSync.mockImplementation(() => {});

      // Track what files are being copied to debug the issue
      mockedFs.copyFileSync.mockImplementation(() => {});

      // Mock console.log for package.json handling
      const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});

      handleComponentCollision(collision);

      expect(mockedFs.readFileSync).toHaveBeenCalledTimes(2);

      // Should handle 2 metafiles
      expect(mockedFs.readFileSync).toHaveBeenCalledWith(
        '/dest/path/package.json',
        'utf-8'
      );
      expect(mockedFs.readFileSync).toHaveBeenCalledWith(
        '/src/path/package.json',
        'utf-8'
      );

      consoleSpy.mockRestore();
    });
  });

  describe('updateHsMetaFilesWithAutoGeneratedFields()', () => {
    const mockUiLogger = vi.mocked(uiLogger);

    beforeEach(() => {
      vi.resetAllMocks();
      mockCoerceToValidUid.mockImplementation((input: string) => input);
    });

    afterEach(() => {
      vi.restoreAllMocks();
    });

    it('updates component metadata files with project-specific UIDs', () => {
      const projectName = 'my-project';
      const hsMetaFilePaths = [
        '/path/to/component1.meta.json',
        '/path/to/component2.meta.json',
      ];

      const component1 = {
        type: 'card',
        uid: 'old-uid-1',
        config: {
          name: 'Old Name',
        },
      };

      const component2 = {
        type: 'function',
        uid: 'old-uid-2',
      };

      mockedFs.readFileSync
        .mockReturnValueOnce(JSON.stringify(component1))
        .mockReturnValueOnce(JSON.stringify(component2));

      mockedFs.writeFileSync.mockImplementation(() => {});

      mockCoerceToValidUid
        .mockReturnValueOnce('card-my-project')
        .mockReturnValueOnce('function-my-project');

      updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);

      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        '/path/to/component1.meta.json',
        JSON.stringify(
          {
            type: 'card',
            uid: 'card-my-project',
            config: {
              name: 'Old Name',
            },
          },
          null,
          2
        )
      );

      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        '/path/to/component2.meta.json',
        JSON.stringify(
          {
            type: 'function',
            uid: 'function-my-project',
          },
          null,
          2
        )
      );

      expect(mockUiLogger.log).toHaveBeenCalledWith(
        'Updating component metadata files...'
      );
      expect(mockUiLogger.log).toHaveBeenCalledWith(
        'Updated card component with uid: card-my-project'
      );
      expect(mockUiLogger.log).toHaveBeenCalledWith(
        'Updated function component with uid: function-my-project'
      );
    });

    it('handles app components by updating both uid and config.name', () => {
      const projectName = 'test-app';
      const hsMetaFilePaths = ['/path/to/app.meta.json'];

      const appComponent = {
        type: 'app',
        uid: 'old-app-uid',
        config: {
          name: 'Old App Name',
          other: 'property',
        },
      };

      mockedFs.readFileSync.mockReturnValue(JSON.stringify(appComponent));
      mockedFs.writeFileSync.mockImplementation(() => {});
      mockCoerceToValidUid.mockReturnValue('app-test-app');

      updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);

      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        '/path/to/app.meta.json',
        JSON.stringify(
          {
            type: 'app',
            uid: 'app-test-app',
            config: {
              name: 'test-app-Application',
              other: 'property',
            },
          },
          null,
          2
        )
      );

      expect(mockUiLogger.log).toHaveBeenCalledWith(
        'Updated app component with uid: app-test-app and name: test-app-Application'
      );
    });

    it('handles UID collisions by using timestamps', () => {
      const projectName = 'collision-project';
      const hsMetaFilePaths = ['/path/to/component1.meta.json'];
      const existingUids = ['card-collision-project'];

      const component1 = { type: 'card', uid: 'old-uid-1' };

      mockedFs.readFileSync.mockReturnValue(JSON.stringify(component1));
      mockedFs.writeFileSync.mockImplementation(() => {});

      // Mock Date.now to return consistent value for testing
      vi.spyOn(Date, 'now').mockReturnValue(1234567890);

      mockCoerceToValidUid
        .mockReturnValueOnce('card-collision-project')
        .mockReturnValueOnce('card-1234567890-collision-project');

      updateHsMetaFilesWithAutoGeneratedFields(
        projectName,
        hsMetaFilePaths,
        existingUids
      );

      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        '/path/to/component1.meta.json',
        JSON.stringify(
          {
            type: 'card',
            uid: 'card-1234567890-collision-project',
          },
          null,
          2
        )
      );
    });

    it('falls back to original uid when coerceToValidUid returns null', () => {
      const projectName = 'fallback-project';
      const hsMetaFilePaths = ['/path/to/component.meta.json'];

      const component = {
        type: 'card',
        uid: 'original-uid',
      };

      mockedFs.readFileSync.mockReturnValue(JSON.stringify(component));
      mockedFs.writeFileSync.mockImplementation(() => {});
      mockCoerceToValidUid.mockReturnValue(undefined);

      updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);

      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        '/path/to/component.meta.json',
        JSON.stringify(
          {
            type: 'card',
            uid: 'original-uid',
          },
          null,
          2
        )
      );
    });

    it('handles empty hsMetaFilePaths array', () => {
      const projectName = 'empty-project';
      const hsMetaFilePaths: string[] = [];

      updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);

      expect(mockedFs.readFileSync).not.toHaveBeenCalled();
      expect(mockedFs.writeFileSync).not.toHaveBeenCalled();
      expect(mockUiLogger.log).toHaveBeenCalledWith(
        'Updating component metadata files...'
      );
      expect(mockUiLogger.log).toHaveBeenCalledWith('');
    });

    it('handles components without config property for app type', () => {
      const projectName = 'no-config-project';
      const hsMetaFilePaths = ['/path/to/app.meta.json'];

      const appComponent = {
        type: 'app',
        uid: 'app-uid',
        // No config property
      };

      mockedFs.readFileSync.mockReturnValue(JSON.stringify(appComponent));
      mockedFs.writeFileSync.mockImplementation(() => {});
      mockCoerceToValidUid.mockReturnValue('app-no-config-project');

      updateHsMetaFilesWithAutoGeneratedFields(projectName, hsMetaFilePaths);

      expect(mockedFs.writeFileSync).toHaveBeenCalledWith(
        '/path/to/app.meta.json',
        JSON.stringify(
          {
            type: 'app',
            uid: 'app-no-config-project',
          },
          null,
          2
        )
      );

      expect(mockUiLogger.log).toHaveBeenCalledWith(
        'Updated app component with uid: app-no-config-project'
      );
    });
  });
});
