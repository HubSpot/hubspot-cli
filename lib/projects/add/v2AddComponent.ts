import { ComponentTemplate, ProjectConfig } from '../../../types/Projects.js';
import { commands, lib } from '../../../lang/en.js';
import { getConfigForPlatformVersion } from '../create/legacy.js';

import {
  calculateComponentTemplateChoices,
  createV2App,
} from '../create/v2.js';
import { PROJECT_WITH_APP } from '../../constants.js';

import path from 'path';
import fs from 'fs';
import { projectAddPromptV2 } from '../../prompts/projectAddPrompt.js';
import {
  HUBSPOT_PROJECT_COMPONENTS_GITHUB_PATH,
  DEFAULT_PROJECT_TEMPLATE_BRANCH,
} from '../../constants.js';
import {
  updateHsMetaFilesWithAutoGeneratedFields,
  handleComponentCollision,
} from '../components.js';

import {
  getProjectMetadata,
  ProjectMetadata,
} from '@hubspot/project-parsing-lib/src/lib/project.js';
import { AppKey } from '@hubspot/project-parsing-lib/src/lib/constants.js';
import { cloneGithubRepo } from '@hubspot/local-dev-lib/github';
import { debugError } from '../../errorHandlers/index.js';
import { uiLogger } from '../../ui/logger.js';
import { trackCommandUsage } from '../../usageTracking.js';

export async function v2AddComponent(
  args: {
    name?: string;
    type?: string;
    features?: string[];
    auth?: string;
    distribution?: string;
    derivedAccountId: number;
  },
  projectDir: string,
  projectConfig: ProjectConfig,
  accountId: number
): Promise<void> {
  uiLogger.log(commands.project.add.creatingComponent(projectConfig.name));

  const config = await getConfigForPlatformVersion(
    projectConfig.platformVersion
  );

  const { components, parentComponents } = config;

  if (!components || !components.length) {
    throw new Error(commands.project.add.error.failedToFetchComponentList);
  }

  const projectSrcDirectory = path.join(projectDir, projectConfig.srcDir);

  const currentProjectMetadata: ProjectMetadata =
    await getProjectMetadata(projectSrcDirectory);

  let derivedAuthType: string | undefined;
  let derivedDistribution: string | undefined;

  const appsMetadata = currentProjectMetadata.components[AppKey];
  const shouldCreateApp = appsMetadata.count === 0;

  if (shouldCreateApp) {
    const { authType, distribution } = await createV2App(
      args.auth,
      args.distribution
    );
    derivedDistribution = distribution;
    derivedAuthType = authType;
  } else if (appsMetadata.count > appsMetadata.maxCount) {
    throw new Error(
      lib.projects.create.errors.exceededMaxNumberOfApps(appsMetadata.maxCount)
    );
  } else {
    const apps = appsMetadata.hsMetaFiles.map(appLoc => {
      try {
        return JSON.parse(fs.readFileSync(appLoc, 'utf8'));
      } catch (err) {
        throw new Error(
          lib.projects.create.errors.unableToParseAppConfig(appLoc)
        );
      }
    });

    derivedDistribution = apps[0].config?.distribution;
    derivedAuthType = apps[0].config?.auth?.type;
  }

  const componentTemplateChoices = await calculateComponentTemplateChoices(
    components,
    derivedAuthType,
    derivedDistribution,
    args.derivedAccountId,
    currentProjectMetadata
  );

  const projectAddPromptResponse = await projectAddPromptV2(
    componentTemplateChoices,
    args.features
  );

  const componentTypes = projectAddPromptResponse.componentTemplate?.map(
    componentTemplate => componentTemplate.cliSelector || componentTemplate.type
  );

  await trackCommandUsage(
    'project-add',
    {
      type: componentTypes?.join(','),
    },
    accountId
  );

  try {
    const components: string[] =
      projectAddPromptResponse.componentTemplate?.map(
        (componentTemplate: ComponentTemplate) => {
          return path.join(
            projectConfig.platformVersion,
            componentTemplate.path
          );
        }
      ) || [];

    if (shouldCreateApp) {
      const parentComponent = parentComponents?.find(possibleParent => {
        return (
          possibleParent.type === PROJECT_WITH_APP &&
          possibleParent.authType === derivedAuthType &&
          possibleParent.distribution === derivedDistribution
        );
      });

      if (parentComponent) {
        components.push(
          path.join(projectConfig.platformVersion, parentComponent.path)
        );
      }
    }

    if (components.length === 0) {
      uiLogger.log(lib.projects.add.nothingAdded);
      return;
    }

    await cloneGithubRepo(HUBSPOT_PROJECT_COMPONENTS_GITHUB_PATH, projectDir, {
      sourceDir: components,
      hideLogs: true,
      branch: DEFAULT_PROJECT_TEMPLATE_BRANCH,
      handleCollision: handleComponentCollision,
    });

    const updatedProjectMetadata: ProjectMetadata =
      await getProjectMetadata(projectSrcDirectory);

    const newHsMetaFiles = updatedProjectMetadata.hsMetaFiles.filter(
      hsMetaFile => !currentProjectMetadata.hsMetaFiles.includes(hsMetaFile)
    );

    const existingUids: string[] = currentProjectMetadata.hsMetaFiles.map(
      hsMetaFile => {
        try {
          const { uid } = JSON.parse(fs.readFileSync(hsMetaFile, 'utf8'));
          return uid;
        } catch (err) {
          return '';
        }
      }
    );

    updateHsMetaFilesWithAutoGeneratedFields(
      projectConfig.name,
      newHsMetaFiles,
      existingUids
    );

    uiLogger.success(
      commands.project.add.success(
        projectAddPromptResponse.componentTemplate
          .map(template => `'${template.label}'`)
          .join(', '),
        projectAddPromptResponse.componentTemplate.length > 1
      )
    );
  } catch (error) {
    debugError(error);
    throw new Error(commands.project.add.error.failedToDownloadComponent, {
      cause: error,
    });
  }
}
